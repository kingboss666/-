* ### 二叉树怎么去通过确定子叶找到其父叶？
  深度优先查询，后序

* ### 深拷贝浅拷贝区别
  浅拷贝对引用数据类型只是增加了一个指针指向已存在的内存地址；
  深拷贝是增加了一个指针并且申请了一个新的内存，使这个指针指向这个新的内存。

* ### 如何去通过规范的方法修改原型链？
  Object.setPrototypeOf(a, b)

* ### promise是如何实现链式调用的？
  promise里面有两个数组,一个存成功时的回调，一个存失败时的回调，如果promise状态为pending就会缓存.then里的回调到两个数组，状态改变了依次调用，并且每次执行后会返回一个带着本次值的全新promise回调，保持链式调用。

* ### 说说你对执行上下文的理解
  &emsp;&emsp;执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行。
  &emsp;&emsp;js里面有三种上下文类型，分别是: 全局执行上下文（默认以及最基础的上下文，不会被栈弹出销毁，浏览器里是window对象，并且将this值绑定在这个全局对象上）；函数执行上下文：每当一个函数调用时都会创建一个新的执行上下文；eval执行上下文。
  &emsp;&emsp;上下文是个抽象的概念，可以把它理解为一个Object，一个执行上下文里面包含：变量对象，活动对象，作用域链，调用者信息。
  1. 变量对象VO：全局作用域的变量对象始终存在，函数作用域的变量对象只在执行中存在。在函数被调用且在运行前，js引擎会把当前函数的参数列表初始化一个“变量对象”并将当前执行上下文与之关联，函数中声明的变量和函数作为属性添加到这个变量对象上（只有函数声明会被加入变量对象中去，函数表达式会被忽略）。
  2. 活动对象AO：函数进入执行阶段时，把原本不能访问的变量对象激活成一个活动对象，自此我们可以访问到各种属性（其实变量对象和活动对象是一个东西，只不过处在不同的状态和阶段而已）。
  3. 作用域链：作用域规定了如何查找变量，当查找变量的时候会先从当前上下文的变量对象中查找，如果没找到就会从父级上下文的变量对象中查找，这样由多个执行上下文的变量对象构成的链表就叫做作用域链。当函数创建时会有个名为\[[scope]]的内部属性保存所有的父变量到其中。函数执行时，会创建一个执行环境，然后通过复制函数的\[[scope]]的内部属性构建起执行环境的作用域链，然后变量对象VO被激活成AO并添加到作用域链的前端，完整作用域创建完成。
  4. 当前可执行代码块的调用者(this)：如果当前函数作为对象方法调用或使用bind、call和apply等API进行委托调用，则将当前代码块的调用者信息存入当前执行上下文，否则默认为全局对象调用。
  &emsp;&emsp;执行上下文的生命周期：创建阶段（变量提升），执行阶段，销毁阶段（闭包）。
  &emsp;&emsp;执行上下文栈：当 JS 引擎开始解析脚本代码时，会首先创建一个全局执行上下文，压入栈底（这个全局执行上下文从创建一直到程序销毁，都会存在于栈的底部）。每当引擎发现一处函数调用，就会创建一个新的函数执行上下文压入栈内，并将控制权交给该上下文，待函数执行完成后，即将该执行上下文从栈内弹出销毁，将控制权重新给到栈内上一个执行上下文。

* ### 简单说说EventLoop
  js是单线程的，为了解决单线程带来的部分弊端，就有了EventLoop的出现。js会先执行主线程任务，遇到微任务就放进微任务队列，遇到宏任务就放入宏任务队列。主线程代码执行完成后就会从微任务队列中去取微任务执行直到微任务队列清空，微任务队列完成后就会从宏任务队列中取出宏任务执行，（主线程代码就是第一个宏任务） 如主线任务一般，遇到微任务放入微任务队列，遇到宏任务放入宏任务队列。重复此过程，这就是事件循环机制。

* ### 微任务中定义微任务在何时触发？
  下次循环后。

* ### 如何理解柯里化？
  但我们的函数有多个参数的时候我们可以对这个函数进行改造，我们可以调用一个函数，只传递部分参数，并且让这个函数返回一个新的函数，这个新的函数去接收剩余的参数，并且返回相应的结果，这就是函数的柯里化。

* ### 简单说说http
  HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。
  1. 超文本：HTTP 传输的内容是超越了普通文本的文本，它是文字图片视频等混合体最关键的超链接，能从一个超文本跳转到另一个超文本。
  2. 传输：HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。
  3. 协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。
  
* ### tcp和udp区别
  1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
  2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
  3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。
  4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
  5. TCP首部开销20字节;UDP的首部开销小，只有8个字节。
  6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

* ### 强缓存和协商缓存区别

* ### react16有什么新特性？
  1. 新的生命周期钩子(compomentDidCatch)
  2. React.Fragments
  3. Hooks
  4. Time Slicing(时间切片)
  5. Suspense 和 lazy配合，实现异步加载组件。

* ### class组件、函数组件和Hooks组件有什么区别？
  
* ### hooks主要解决了什么问题？
  在hooks之前 React存在很多问题：在组件间复用状态逻辑很困难，复杂组件变得难以理解，高阶组件和函数组件嵌套过深，class组件this指向问题，复杂的生命周期函数。Hooks很好的解决上面的问题。


* ### 怎么优化React Hooks？
  1. 优化组件状态管理混乱：不需要把组件的各个状态都用useState进行初始化， 和视图层没有关系的状态可以使用useRef来定义。
  2. Props无关渲染：一个父组件下有两个子组件通过不同的props管理，如果只有一个子组件触发更新，那么另一个不需要更新的子组件也会刷新，造成不必要的性能浪费。可以使用useMemo包裹子组件，进行缓存。还可以进一步优
  3. 化子组件的内部，如果只有props的部分属性才造成更新，可以用useMemo, useCallback来缓存高开销的计算。

* ### useEffect是怎么实现清除副作用的？

* ### useRef使用场景
  1. 函数组件访问dom元素。
  2. 函数组件访问之间渲染的变量。
  useRef特点：返回的ref对象在组件的整个生命周期内保持不变,当更新current时并不会触发render，更新useRef是 side effect (副作用)，所以一般写在useEffect或event handler里。

* ### 怎么使用hooks实现改变一个值的同时不触发刷新，并且没有副作用
  使用useRef定义这个参数